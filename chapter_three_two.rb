#[3.2]Minitestの基本
#テストの重要性を理解したところで、実際にどうやるのかを見ていきましょう！

#テストを自動化するにはテスト用のフレームワークを利用します。
#Rubyにはいくつかのテストフレームワークが存在しますが、今回はMinitestというフレームワークを利用します。
# ==> Minitestを選んだ理由
#    ①Rubyをインストールすると、一緒にインストールされるため、特別なセットアップがいらない。
#    ②学習コストが比較的低い。
#    ③Railsのデフォルトのテスティングフレームワークなので、Railsを開発するときにも知識を活かせる。

#テストの自動化というと何かすごいことをするように感じるかもしれませんが、実際はそれほど難しいものではありません。
#　==> 必要な手順は次の通り
#      ①テスティングフレームワークのルールに沿って、プログラムの実行結果を検証するRubyプログラム(テストコード)を書く。
#      ②上記①で作ったテストコードを実行する。
#      ③テスティングフレームワークが実行結果をチェックし、その結果が正しいか間違っているかを報告する。

#[3.2.1]テストコードの雛形
# EX Minitestを使ったテストコードの基本形
  require 'minitest/autorun'

  class SampleTest < Minitest::Test
    def test_sample
      assert_equal 'RUBY', 'ruby'.upcase
    end
  end

# ==> 19行目の「require 'minitest/autorun'」はライブラリを読み込んでプログラム内でMinitestを使えるようにするためのコードです。

# ==> 21行目の「class SampleTest < Minitest::Test」から25行目までの「end」までが、テストコードの本体(テストクラス)です。

# ==> 「SampleTest」はクラスの名前です。命名は自由ですが、慣習として「JapaneseCalendarTest」や「TestOrderItem」など、Testで終わるまたは始まる名前をつけることが多い。
#　　　 またファイル名は「japanese_calendar_test.rb」や「test_order_item.rb」のように、クラス名と合わせます。
#      クラスの名前は「キャラメルケース」、ファイルの名前は「スネークケース」で書きます！

# ==> 「< Minitest::Test」の部分は「SampleTestクラスがMinitest::Testクラスを継承する」ことを表している！（詳細は７章にて）

# ==> 22行目から24行目までが実行対象となるテストメソッドです。Minitestは「test_」で始まるメソッドを探して、それを実行します。
#     なので、メソッド名は「test_」で始めることが必須になります。
#     test_から後ろの部分は自由ですが、「test_item_name」や「test_send_mail」など、メソッド内でテストする内容が推測できるような名前をつけましょう！
#     なお、「test_」で始まるメソッドを複数定義しても構いません。Minitestはtest_で始まるメソッドを全て実行します。

# ==> 24行目「assert_equal 'RUBY', 'ruby'.upcase」が実行結果するための検証メソッドです。
#     ここではMinitestが提供する「assert_equalメソッド」を使って「'ruby'.upcase」の実行結果が「'RUBY'」になっていると検証しています。
#     「assert_equalメソッド」は次のように使います。引数を渡す順番に気をつけましょう！
#　EX  assert_equal 期待する結果, テスト対象になる値や式
