#[2.10]真偽値と条件分岐ついてもっと詳しく

#[2.10.1]「&&」や「||」の戻り値と評価を終了するタイミング
#「&&」や「||」を使った場合、式全体の戻り値は必ずしもtrueまたはfalseになるとは限らない。

#全ての式を評価する必要があったため戻り値は「３」になる。
puts 1 && 2 && 3

#2つ目のnilを評価した時点で式全体の真偽値が偽であることが確定するのでそこで評価が終了してnilを返す。
puts 1 && nil && 3
puts 1 && false && 3

#「||」の場合でも同じ考え方で左辺から順に評価していく。
puts nil || false
puts false || nil
puts nil || false || 2 || 3

#if文のように「真または偽のどちらか」であればかまわないケースでは、戻り値に具体的に何であるか意識する必要はない！
#しかし、Rubyではif文以外のところで「&&」や「||」を意図的に使う場合がある。

#EX Alice,Bob,Carolと順に検索して最初に見つかったユーザー(nilまたはfalse以外の値)を変数に格納する。
user = find_user('alicec') || find_useer('Bob') || find_user('Carol')

#EX 正常なユーザーであればメールを送信する。(左辺が偽であればメール送信は実行されtない)
user.valid? && send_email_to(user)

#[2.10.2]優先順位が低い「and」,「or」,「not」
#「&&」,「||」,「!」に近い働きをする演算子として「and」,「or」,「not」がある。
#ただし、「and」,「or」,「not」は演算子の優先順位が低いため、「&&」,「||」,「!」と全く同じようには使うことはできない
優先順位
高い  !
     &&
     ||
     not
低い  and or

#EX 英語の論理演算子と記号の論理演算子を混在させたりすると結果が異なる
t1 = true
f1 = false
puts !t1 || t1
# => !(f1) || t1 の意味になる【「!」は「||」よりも優先順位が高い。】
puts not f1 || t1
# => not (f1 || t1)の意味になる【「not」は「||」よりも優先順位が低い。】

#「and」と「or」は優先順位に違いがないため「()」を使わない場合は左から右に順番に真偽値が評価される。
t1 = true
t2 = true
f1 = false

puts t1 || t2 && f1
# => true
# => 「&&」は「||」よりも優先順位が高い
# t1 || (t2 && f1)と同じ意味になる

puts t1 or t2 and f1
# => false
# => 「and」は「or」の優先順位は同じなので左から順に評価される
# (t1 or t2) and f1と同じ意味になる

#上記のような特徴があるため「and」や「or」を「&&」や「||」の代わりに使おうとすると思いがけない不具合を招く可能性があるので注意。

#「and」や「or」は条件分岐で使うのではなく、制御フローを扱うに向いている。

#EX 「正常なユーザーであればメールを送信する」という架空のコードからメソッド呼び出しの丸括弧を無くした場合
user.valid? && send_mail_to user
# => このままだと「構文エラー(SyntaxError)」になってしまう
# userに丸括弧を付けると処理が明確になるので構文エラーにはならない。
#以下のように解釈されてしまったために構文エラーが発生してしまっている
(user.valid? && send_mail_to) user
#ここで「and」を使うと次のように解釈されて構文エラーにはならない。
user.valid? and send_mail_to user == (user.valid?) and (send_mail_to user)

#EX 「or」も「Aか真か？真でなければBせよ」という制御フローを実現する際に便利
def greeting(country)
  #countryがnil(またはfalse)ならメッセージを返してメソッドを抜ける
  country or return 'countryを入力してください'

  if country == 'japan'
    puts 'こんにちは'
  else
    puts 'hello'
  end
end
______