#[2.12]その他の基本知識

#[2.12.1]ガべージコレクション(GC)
#Rubyは使用しなくたなったオブジェクションを回収し、自動的にメモリを解放する。
#このため、プログラマはメモリ管理を意識する必要がない。この仕組みをガベージコレクションという。

#[2.12.2]エイリアスメソッド
#Rubyには全く同じメソッドに複数の名前が付いている場合がよくある。

#EX 名前だけ異なる同じメソッド
  puts 'hello'.length # ==> 5
  puts 'hello'.size   # ==> 5

#上記のようなメソッドのことを「エイリアスメソッド」と呼ぶ。
#「length」と「size」のように、同じメソッドに複数の名前が用意されている場合は、開発者の好みでしっくりくる方を選んでOK！
#また、エイリアスメソッドは自分で定義することもできる。


#[2.12.3]式(Expression)と文(Statement)
#Rubyでは、他の言語では文とみなされるような要素が式になっていることが多い。
#ここでは、「値を返し、結果を変数に代入できるものを式」「値を返さず、変数に代入しようとすると構文エラーになるものを文」と定義する。

#このように分類ではRubyのif文やメソッド定義は文ではなく、式になってしまう。
#なぜならif文もメソッド定義も値を返すから！

# EX if文が値を返すので変数に代入できる
  a =
    if true
      puts '真です'
    else
      puts '偽です'
    end
  puts a #==> 真です

# EX メソッド定義も実は値(シンボル)を返している
  b = def foo; end
  puts b # ==> foo

#よって厳密に言えば「if式」「メソッド定義式」と呼んだ方が実態に即している。
#しかし、必ずしも式のように扱われるとは限らず、戻り値が無視されるケースも多いので、本書では厳密な区別はしない。
#ですが、Rubyでは「文のように見えるが実は式」という要素が多い。つまり、やろうと思えば戻り値を活用できることを頭の片隅に置いておく！

#[2.12.4]疑似変数
#このようで登場した「nil」と「true」と「false」は疑似変数とよばれる特殊な変数。
#このほかにもRubyには次のような疑似変数がある。

slef          # ==> オブジェクト自身
__FLLE___     # ==> 現在のソースファイル
__LINE__      # ==> 現在のソースファイル中の行番号
__ENCODING__  # ==> 現在のソースファイルのスクリプトエンコーディング

#疑似変数は文法上変数のように見えないが、代入しようとするとエラーが発生する。
#つまり、特定のオブジェクトが代入されており、ユーザーは変更できない。

#[2.12.5]参照の概念を理解する。
#RUbyの変数にはオブジェクトそのものではなく、オブジェクトへの参照が格納される。
#変数を他の変数に代入したり、メソッドの引数として渡したりすると、新しい変数やメソッドの引数は元の変数と同じオブジェクトを参照する。

# EX (変数がどのオブジェクトを参照しているかは「object_idメソッド」を使うとわかる)
  
  a = 'hello'
  b = 'hello'
  puts a.object_id  # ==> 70333369894540
  puts b.object_id  # ==> 70333369894520
  # ==> 文字列は同じだが、オブジェクトとしては別物！

  #cにbを代入する
  c = b
  puts c.object_id  # ==> 70333369894520
  # ==> bとcはどちらも同じオブジェクト

  #メソッドの引数にcを渡す
  def m!(d)
    d.object_id
  end
  puts m!(c)   # ==> 70333369894520
  # ==> 引数として受け取ったdはb、cと同じオブジェクト

  #「equal?メソッド」を使って同じオブジェクトかどうか確認してもいい(trueなら同じオブジェクト)
  puts a.equal?(b)  # ==> false
  puts b.equal?(c)  # ==> true

#同じオブジェクトを参照している場合、オブジェクトの状態が変更されると、その変更がそのまま各変数に影響する。
# EX 変更した変数が同じオブジェクト参照している場合
  #b、cは同じオブジェクト、aは異なるオブジェクト
  a = 'hello'
  b = 'hello'
  c = b

  #渡された文字列を破壊的に大文字に変換するメソッドを定義する。
  def m!(d)
    d.upcase!
  end

  #cにm!メソッドを適用する
  puts m!(c)

  #b、cはいずれも大文字になる
  puts b  # ==> HELLO
  puts c  # ==> HELLO

  #aは別のオブジェクトなので大文字にならない
  puts a

#文字列や配列、ハッシュといった変更可能なオブジェクト(ミュータブルなオブジェクト)を扱う場合は、
#同一のオブジェクトを参照しているのか、異なるオブジェクトを参照しているのかを意識しないと、思いがけないバグを作り込んでしまう可能性があるので注意！

#[2.12.6]組み込みライブラリ、標準ライブラリ、gem
#Rubyには最初から数多くのライブラリが標準ライブラリとして用意されている。
#その中でも使用頻度が高いライブラリは組み込みライブラリとして提供されている。
#インストール不要
# ------ 標準ライブラリ ------
#   -- 組み込みライブラリ --
      # String,Interger
      # Array,Hash ...etc
#   ---------------------
  #date,fileutils,csv,json
  #     yaml ...etc
# --------------------------

#また、有志の開発者が作成している外部ライブラリはgemと呼ばれる形式でパッケージングされている。
#別途インストールが必要
# ---- gem ----
     #bundler
     #rails
     #rspec
     #nokogiri
     #sinatra
     #...etc
# --------------

#[2.12.7]require
#組み込みライブラリでない標準ライブラリやgemを利用する場合は、明示的にそのライブラリを組み込む必要がある。

require ライブラリ名

# EX Dateクラスを使いたい場合はdateライブラリを組み込む
  #Dateクラスは組み込みライブラリではないので、そのままでは使用できない。
  puts Date.today   # ==> (NameError) uninitialized constant Date

  #dateライブラリを組み込むとDateクラスを使えるようになる
  require 'date'
  puts Date.today   # ==> 2021-06-10

#また、自分で作成したRubyプログラム(クラスの定義など)を読み込む場合もrequireを使う。
#この場合はRubyを実行しているディレクトリからの相対パス、または絶対パスで指定する。

# EX 同じディレクトリに自分で作成したsample.rbというファイルがあり、それを読み込みたい場合
  require './sample.rb'
  #拡張子のrbは省略可能なので次のように書くこともできる。
  require './sample'
  #ただし、いずれにしても「./(現在のディレクトリ)」「/(ルートディレクトリ)」を使って、相対パスや絶対パスの形式で書き始める必要がある。

#[2.12.8]load
#requireは1回しかライブラリやrbファイルを読み込まない、という点に少し注意が必要。
#requireを使った時にfalseが返ってきた場合は、既に読み込み済みであることを示している。

# EX
  #自分でかいたプログラムを読み込む
  require './sample'

  # ==> 不具合があったのでsample.rbを修正

  #しかし、もう一度requireしても既に読み込み済みなので修正が反映されない。
  require './sample'  # ==> false

#このような場合において「load」と使うと、毎回無条件に指定したファイルを読み込むことができる。

load './sample.rb'  # ==> true

#loadを使うと無条件に再読み込みできる(なのでファイルの変更が反映される)
#ただし、loadを使う場合は拡張子を省略できないので注意が必要！

#[2.12.9]require_ralative
#requireはRubyを実行しているディレクトリがパスの起点になるが、require_ralativeを使うと自分のファイルが存在するディレクトリがパスの起点になる。

# EX 次のようにファイルが配置されている場合